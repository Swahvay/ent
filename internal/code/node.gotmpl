{{reserveImport "context"}}
{{reserveImport "errors"}} 
{{reserveImport "strings"}}
{{reserveImport "sync"}}

{{reserveImport	"github.com/google/uuid" }}
{{reserveImport	"github.com/lolopinto/ent/ent" }}
{{reserveImport	"github.com/lolopinto/ent/ent/cast" }}
{{reserveImport	"github.com/lolopinto/ent/ent/privacy" }}
{{reserveImport	"github.com/lolopinto/ent/ent/viewer" }}
{{reserveImport "golang.org/x/crypto/bcrypt" }}

{{reserveImport .CodePath.GetQuotedImportPathToConfigs}}

{{with .NodeData -}}
{{ $constGroup := .ConstantGroups -}}

{{with .GetSortedConstantGroups -}}

{{ range . -}}
  {{if .CreateNewType -}}
  type {{.ConstType}} string
  {{end -}}
{{end -}}

const (
  {{ range . -}}
    {{$constType := .ConstType -}}
    {{range .GetSortedConstants -}}
      // {{.Comment}}
      {{.ConstName}} {{$constType}} = {{.ConstValue}}
    {{end}}

  {{end -}}
)
{{end -}}

{{with . -}}
  {{$currentNodeInstance := .NodeInstance}}
  {{$currentNode := .Node}}
  {{$currentPackageName := .PackageName}}
  {{$currentConfig := .EntConfig}}

  // {{.Node}} represents the `{{.Node}}` model 
  type {{.Node}} struct {
    ent.Node
    {{/* TODO, this needs to be configurable but this is fine for now */ -}}
    privacy.AlwaysDenyPrivacyPolicy
    {{ range $field := .FieldInfo.Fields -}} 
      {{if $field.TopLevelStructField -}}
        {{$field.GetFieldNameInStruct}} {{fTypeString $field}} {{$field.GetFieldTag}}
      {{end -}}
    {{end -}}
    Viewer viewer.ViewerContext
  }

//  type {{.Nodes}} map[string]{{.Node}}


  // {{.NodeResult}} stores the result of loading a {{.Node}}. It's a tuple type which has 2 fields: 
  // a {{.Node}} and an error
  type {{.NodeResult}} struct {
    {{.Node}} *{{.Node}}
    Err error
  }

  func (res *{{.NodeResult}}) Error() string {
    return res.Err.Error()
  }

  // {{.NodesResult}} stores the result of loading a slice of {{.Node}}s. It's a tuple type which has 2 fields: 
  // a {{.NodesSlice}} and an error
  type {{.NodesResult}} struct {
    {{.Nodes}} {{.NodesSlice}}
    Err error
  }

  func (res *{{.NodesResult}}) Error() string {
    return res.Err.Error()
  }

  // TODO this is going to be used to load a new object 
  type {{.NodesLoader}} struct {
    nodes map[string]*{{.Node}}
    errs map[string]error
    results {{.NodesSlice}}
    m sync.Mutex
  }

  func (res *{{.NodesLoader}}) GetNewInstance() ent.DBObject {
    var {{.NodeInstance}} {{.Node}}
    return &{{.NodeInstance}}
  }

  func (res *{{.NodesLoader}}) GetConfig() ent.Config {
    return {{.EntConfig}}
  }

  func (res *{{.NodesLoader}}) SetPrivacyResult(id string, obj ent.DBObject, err error) {
    res.m.Lock()
    defer res.m.Unlock()
    if err != nil {
      res.errs[id] = err
    } else if obj != nil {
      // TODO kill results?
      ent := obj.(*{{.Node}})
      res.nodes[id] = ent
      res.results = append(res.results, ent)
    }
  }

  // TODO???
  func (res *{{.NodesLoader}}) List() {{.NodesSlice}} {
    return res.results
  }

  func {{.NewNodesLoader}}() *{{.NodesLoader}} {
    return &{{.NodesLoader}}{
      nodes: make(map[string]*{{.Node}}),
      errs: make(map[string]error),
    }
  }


  // IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
  func ({{.NodeInstance}} {{.Node}}) IsNode() {}

  // GetType returns the NodeType of this entity. In this case: ContactType
  func ({{.NodeInstance}} *{{.Node}}) GetType() ent.NodeType {
    return {{.NodeType}}
  }

  // GetViewer returns the viewer for this entity.
  func ({{.NodeInstance}} *{{.Node}}) GetViewer() viewer.ViewerContext {
    return {{.NodeInstance}}.Viewer
  }

  // GetConfig returns the config for this entity.
  func ({{.NodeInstance}} *{{.Node}}) GetConfig() ent.Config {
    return {{.EntConfig}}
  }

  // Load{{.Node}}FromContext loads the given {{.Node}} given the context and id
  func Load{{.Node}}FromContext(ctx context.Context, id string) (*{{.Node}}, error) {
    v, err := viewer.ForContext(ctx)
    if err != nil {
      return nil, err
    }
    return Load{{.Node}}(v, id)
  }

  // GenLoad{{.Node}}FromContext loads the given {{.Node}} given the context and id
  func GenLoad{{.Node}}FromContext(ctx context.Context, id string) <-chan *{{.NodeResult}} {
    res := make(chan *{{.NodeResult}})
    go func() {
      v, err := viewer.ForContext(ctx)
      if err != nil {
        res <- &{{.NodeResult}}{
          Err: err,
        }
        return
      }
      res <- <- (GenLoad{{.Node}}(v, id))
    }()
    return res
  }

  // Load{{.Node}} loads the given {{.Node}} given the viewer and id
  func Load{{.Node}}(v viewer.ViewerContext, id string) (*{{.Node}}, error) {
    var {{.NodeInstance}} {{.Node}}
    err := ent.LoadNode(v, id, &{{.NodeInstance}})
    return &{{.NodeInstance}}, err
  }

  // GenLoad{{.Node}} loads the given {{.Node}} given the id
  func GenLoad{{.Node}}(v viewer.ViewerContext, id string) <-chan *{{.NodeResult}}{
    res := make(chan *{{.NodeResult}})
    go func() {
      var result {{.NodeResult}}
      var {{.NodeInstance}} {{.Node}}
      result.Err = <- ent.GenLoadNode(v, id, &{{.NodeInstance}})
      result.{{.Node}} = &{{.NodeInstance}}
      res <- &result
    }()
    return res
  }

  // Load{{.Nodes}} loads multiple {{.Nodes}} given the ids
  func Load{{.Nodes}}(v viewer.ViewerContext, ids ...string) ({{.NodesSlice}}, error) {
    loader := {{.NewNodesLoader}}()
    err := ent.LoadNodes(v, ids, loader)
    return loader.results, err
  }

  // GenLoad{{.Nodes}} loads multiple {{.Nodes}} given the ids
  func GenLoad{{.Nodes}}(v viewer.ViewerContext, ids ...string) <-chan *{{.NodesResult}} {
    res := make(chan *{{.NodesResult}})
    go func() {
      loader := {{.NewNodesLoader}}()
      var result {{.NodesResult}}
      result.Err = <-ent.GenLoadNodes(v, ids, loader)
      result.{{.Nodes}} = loader.results
      res <- &result
    }()
    return res
  }

  {{ range $field := .FieldInfo.Fields -}} 
    {{if or $field.Index $field.Unique -}}
      func Load{{$currentNode}}IDFrom{{$field.FieldName}}({{$field.InstanceFieldName}}  {{notNullableTypeString $field}}) ({{notNullableTypeString $field}}, error) {
        // TODO this is a short term API that needs to be killed
        // since it shouldn't be possible to get an ent without privacy
        // change the underlying API to only return a map[string]interface{} or something else
        var {{$currentNodeInstance}} {{$currentNode}}
        err := ent.LoadNodeFromParts(&{{$currentNodeInstance}}, {{$currentConfig}}, {{$field.GetQuotedDBColName}}, {{$field.InstanceFieldName}})
        if err != nil {
          return "", err
        }
        return {{$currentNodeInstance}}.ID, nil
      }

      {{/* func Load{{.Node}}From{{$field.FieldName}}(viewer viewer.ViewerContext, {{$field.FieldInstanceName}} {{fTypeString $field}}) ({{.Node}} error) {
        var {{.NodeInstance}} {{.Node}}
        err := ent.LoadNodeFromParts(&{{.NodeInstance}}, {{.EntConfig}}, {{$field.GetQuotedDBColName}}, {{.NodeInstance}})
        return {{.NodeInstance}}}, err
      } */}}
    {{end -}}
  {{end -}}

  {{ if $combo := .FieldInfo.GetEmailPasswordCombo -}}
    {{$emailField := $combo.Email -}}
    {{$passwordField := $combo.Password -}}
    func ValidateEmailPassword(emailAddress, password string) (string, error) {
      var {{$currentNodeInstance}} {{$currentNode}}
      err := ent.LoadNodeFromParts(&{{$currentNodeInstance}}, {{$currentConfig}}, "{{$emailField.GetDbColName}}", emailAddress)
      if err != nil {
        return "", err
      }

      if err := bcrypt.CompareHashAndPassword([]byte({{$currentNodeInstance}}.{{$passwordField.GetFieldNameInStruct}}), []byte(password)); err != nil {
        return "", err
      }
      
      return {{$currentNodeInstance}}.ID, nil
    }
  {{ end -}}

  {{/* todo: deal with importing right packages above and circular dependency all that jazz*/}}
  {{/* this should be user/factory. user/config? user/query user/privacy etc. */}}
  {{with .EdgeInfo}}
    {{range $edge := .FieldEdges -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}() <-chan *{{.NodeResult}}{
          return GenLoad{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}})
        }

        // Load{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() (*{{.Node}}, error) {
          return Load{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}})
        }
      {{end}}
    {{end}}
    {{range $edge := .ForeignKeys -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}() <-chan *{{.NodesResult}} {
          res := make(chan *{{.NodesResult}})
          go func() {
            loader := {{.NewNodesLoader}}()
            var result {{.NodesResult}}
            result.Err = <- ent.GenLoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, "{{$currentPackageName}}_id", loader)
            result.{{.Nodes}} = loader.results
            res <- &result
          }()
          return res
        }

        // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
          loader := {{.NewNodesLoader}}()
          err := ent.LoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, "{{$currentPackageName}}_id", loader)
          return loader.results, err
        }
      {{end}}
    {{end}}
    {{range $edge := .Associations -}}
      {{$edgeName := .EdgeName -}}
      {{$uniqueEdge := .Unique}}
      {{with .NodeInfo -}}

        {{ if $uniqueEdge -}}
          // Load{{$edgeName}}Edge returns the {{$edgeName}} edge associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}Edge() (*ent.AssocEdge, error) {
            return ent.LoadUniqueEdgeByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}}Edge returns the {{$edgeName}} edge associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}Edge() <-chan *ent.AssocEdgeResult {
            return ent.GenLoadUniqueEdgeByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}} returns the {{.Node}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}() <-chan *{{.NodeResult}} {
            res := make(chan *{{.NodeResult}})
            go func() {
              var result {{.NodeResult}}
              var {{.NodeInstance}} {{.Node}}
              result.Err = <-ent.GenLoadUniqueNodeByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}})
              result.{{.Node}} = &{{.NodeInstance}}
              res <- &result
            }()
            return res
          }

          // Load{{$edgeName}} returns the {{.Node}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() (*{{.Node}}, error) {
            var {{.NodeInstance}} {{.Node}}
            err := ent.LoadUniqueNodeByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}})
            return &{{.NodeInstance}}, err
          }
        {{else -}}
          // Load{{$edgeName}}Edges returns the {{$edgeName}} edges associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}Edges() ([]*ent.AssocEdge, error) {
            return ent.LoadEdgesByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}}Edges returns the {{.Node}} edges associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}Edges() <-chan *ent.AssocEdgesResult {
            return ent.GenLoadEdgesByType({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}})
          }

          // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}() <-chan *{{.NodesResult}} {
            res := make(chan *{{.NodesResult}})
            go func() {
              loader := {{.NewNodesLoader}}()
              var result {{.NodesResult}}
              result.Err = <-ent.GenLoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, loader)
              result.{{.Nodes}} = loader.results
              res <- &result
            }()
            return res
          }

          // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
          func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
            loader := {{.NewNodesLoader}}()
            err := ent.LoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, loader)
            return loader.results, err
          }
        {{end -}}


        // Load{{$edge.Singular}}EdgeFor loads the ent.AssocEdge between the current node and the given id2 for the {{$edgeName}} edge.
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edge.Singular}}EdgeFor(id2 string) (*ent.AssocEdge, error) {
          return ent.LoadEdgeByType({{$currentNodeInstance}}.ID, id2, {{$edge.EdgeConst}})
        }

        // Gen{{$edge.Singular}}EdgeFor provides a concurrent API to load the ent.AssocEdge between the current node and the given id2 for the {{$edgeName}} edge.
        func ({{$currentNodeInstance}} *{{$currentNode}}) GenLoad{{$edge.Singular}}EdgeFor(id2 string) <-chan *ent.AssocEdgeResult {
          return ent.GenLoadEdgeByType({{$currentNodeInstance}}.ID, id2, {{$edge.EdgeConst}})
        }
      {{end}}
    {{end }}

    {{range $assocEdgeGroup := .AssocGroups -}}
      {{- $const := $assocEdgeGroup.ConstType -}}
      {{$funcName := $assocEdgeGroup.GetStatusFuncName -}}
      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$funcName}}() (*{{$const}}, error) {
        if !viewer.HasIdentity({{$currentNodeInstance}}.Viewer) {
          ret := {{$assocEdgeGroup.GetConstNameForUnknown}}
      		return &ret, nil
        }
        statusMap := {{$currentNodeInstance}}.{{$assocEdgeGroup.GroupStatusName}}Map()
        edges := make(map[string]*ent.AssocEdge)
        errs := make(map[string]error)
        for key, data := range statusMap {
          // TODO concurrent versions
          edges[key], errs[key] = ent.LoadEdgeByType({{$currentNodeInstance}}.ID, {{$currentNodeInstance}}.Viewer.GetViewerID(), data.Edge)
        }
        for _, err := range errs {
          if err != nil {
            return nil, err
          }
        }
        var ret {{$const}}
        for key, edge := range edges {
          // TODO better zero value behavior at some point
      		if edge != nil && edge.ID1 != "" {
            var ok bool
            ret, ok = statusMap[key].ConstName.({{$const}})
            if !ok {
      				return nil, errors.New("error casting constant to {{$const}}")
      			}
            break
          }
        }
        return &ret, nil
      }

      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$funcName}}ForGQL() (*string, error) {
        enum, err := {{$currentNodeInstance}}.{{$assocEdgeGroup.GetStatusFuncName}}()
        if err != nil {
          return nil, err
        }
        str := string(*enum)
        return &str, nil
      }

      func ({{$currentNodeInstance}} *{{$currentNode}}) {{$assocEdgeGroup.GroupStatusName}}Map() ent.AssocStatusMap {
        {{ $constInfo := index $constGroup $const -}}
        return ent.AssocStatusMap {
        {{ range $assocEdge := $assocEdgeGroup.Edges -}}
          {{ $edgeName := $assocEdge.EdgeName -}}
          {{ $constName := $assocEdgeGroup.GetConstNameForEdgeName $edgeName -}}
          {{ $constInfo := index $constInfo.Constants $constName -}}
          {{ $constInfo.ConstValue}}: &ent.AssociationEdgeGroupStatusInfo{
            EdgeName: "{{$edgeName}}",
            Edge: {{$assocEdge.EdgeConst}},
            ConstName: {{$constName}},
            {{ if $assocEdgeGroup.UseEdgeInStatusAction $edgeName -}}
              UseInStatusAction: true,
            {{ else -}}
              UseInStatusAction: false,
            {{ end -}}
          },
        {{ end -}}
        }
      }
    {{ end -}}
  {{end}}

// DBFields is used by the ent framework to load the ent from the underlying database
func ({{$currentNodeInstance}} *{{$currentNode}}) DBFields() ent.DBFields {
  return ent.DBFields {
    "id": func(v interface{}) error {
      var err error
      {{$currentNodeInstance}}.ID, err = cast.ToUUIDString(v)
      return err
    },
    {{ range $field := .FieldInfo.Fields -}}
      {{if $field.TopLevelStructField -}}
        "{{$field.GetDbColName}}": func(v interface{}) error {
          {{if ne $field.GetCastToMethod "cast.UnmarshallJSON" -}}
            var err error
            {{$currentNodeInstance}}.{{$field.GetFieldNameInStruct}}, err = {{$field.GetCastToMethod}}(v)
            return err
          {{else -}}
            return cast.UnmarshallJSON(v, &{{$currentNodeInstance}}.{{$field.GetFieldNameInStruct}})
          {{end -}}
        },
      {{end -}}
    {{end -}}
  }
}

{{if or .HasJSONField .HasPrivateField -}}
  // UnsupportedScan flags that we can't call StructScan() on the ent to get data out of the db, have to always use MapScan() and DBFields() method above
  func ({{$currentNodeInstance}} *{{$currentNode}}) UnsupportedScan() bool {
    return true
  }
{{end -}}

{{end}}

var _ ent.Entity = &{{.Node}}{}

{{end -}}
