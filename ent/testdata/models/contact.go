// Code generated by github.com/lolopinto/ent/ent, DO NOT edit.

package models

import (
	"context"

	"github.com/lolopinto/ent/ent"
	"github.com/lolopinto/ent/ent/cast"
	"github.com/lolopinto/ent/ent/viewer"

	"/Users/ola/code/ent/ent/testdata/models/configs"
)

const (
	// ContactType is the node type for the Contact object. Used to identify this node in edges and other places.
	ContactType ent.NodeType = "contact"
)

// Contact represents the `Contact` model
type Contact struct {
	ent.Node
	EmailAddress string `db:"email_address"`
	FirstName    string `db:"first_name"`
	LastName     string `db:"last_name"`
	UserID       string `db:"user_id"`
	Viewer       viewer.ViewerContext
}

// ContactResult stores the result of loading a Contact. It's a tuple type which has 2 fields:
// a Contact and an error
type ContactResult struct {
	Contact *Contact
	Error   error
}

// ContactsResult stores the result of loading a slice of Contacts. It's a tuple type which has 2 fields:
// a []*Contact and an error
type ContactsResult struct {
	Contacts []*Contact
	Error    error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func (contact Contact) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func (contact *Contact) GetType() ent.NodeType {
	return ContactType
}

// GetPrivacyPolicy returns the PrivacyPolicy of this entity.
func (contact *Contact) GetPrivacyPolicy() ent.PrivacyPolicy {
	return ContactPrivacyPolicy{
		Contact: contact,
	}
}

// LoadContactFromContext loads the given Contact given the context and id
func LoadContactFromContext(ctx context.Context, id string) (*Contact, error) {
	v, err := viewer.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	return LoadContact(v, id)
}

// LoadContact loads the given Contact given the viewer and id
func LoadContact(viewer viewer.ViewerContext, id string) (*Contact, error) {
	var contact Contact
	err := ent.LoadNode(viewer, id, &contact, &configs.ContactConfig{})
	return &contact, err
}

// GenLoadContact loads the given Contact given the id
func GenLoadContact(viewer viewer.ViewerContext, id string, chanContactResult chan<- ContactResult) {
	var contact Contact
	chanErr := make(chan error)
	go ent.GenLoadNode(viewer, id, &contact, &configs.ContactConfig{}, chanErr)
	err := <-chanErr
	chanContactResult <- ContactResult{
		Contact: &contact,
		Error:   err,
	}
}

func (contact *Contact) FillFromMap(data map[string]interface{}) error {
	for k, v := range data {
		var err error
		switch k {
		case "id":
			contact.ID, err = cast.ToUUIDString(v)
			if err != nil {
				return err
			}
			break
		case "email_address":
			contact.EmailAddress, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		case "first_name":
			contact.FirstName, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		case "last_name":
			contact.LastName, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		case "user_id":
			contact.UserID, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		}
	}
	return nil
}

var _ ent.Entity = &Contact{}
