// Code generated by github.com/lolopinto/ent/ent, DO NOT edit.

package models

import (
	"context"

	"github.com/lolopinto/ent/ent"
	"github.com/lolopinto/ent/ent/cast"
	"github.com/lolopinto/ent/ent/viewer"

	"/Users/ola/code/ent/ent/testdata/models/configs"
)

const (
	// UserType is the node type for the User object. Used to identify this node in edges and other places.
	UserType ent.NodeType = "user"

	// UserToEventsEdge is the edgeType for the user to events edge.
	UserToEventsEdge ent.EdgeType = "41bddf81-0c26-432c-9133-2f093af2c07c"
)

// User represents the `User` model
type User struct {
	ent.Node
	EmailAddress string `db:"email_address"`
	FirstName    string `db:"first_name"`
	LastName     string `db:"last_name"`
	Viewer       viewer.ViewerContext
}

// UserResult stores the result of loading a User. It's a tuple type which has 2 fields:
// a User and an error
type UserResult struct {
	User  *User
	Error error
}

// UsersResult stores the result of loading a slice of Users. It's a tuple type which has 2 fields:
// a []*User and an error
type UsersResult struct {
	Users []*User
	Error error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func (user User) IsNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func (user *User) GetType() ent.NodeType {
	return UserType
}

// GetPrivacyPolicy returns the PrivacyPolicy of this entity.
func (user *User) GetPrivacyPolicy() ent.PrivacyPolicy {
	return UserPrivacyPolicy{
		User: user,
	}
}

// LoadUserFromContext loads the given User given the context and id
func LoadUserFromContext(ctx context.Context, id string) (*User, error) {
	v, err := viewer.ForContext(ctx)
	if err != nil {
		return nil, err
	}
	return LoadUser(v, id)
}

// LoadUser loads the given User given the viewer and id
func LoadUser(viewer viewer.ViewerContext, id string) (*User, error) {
	var user User
	err := ent.LoadNode(viewer, id, &user, &configs.UserConfig{})
	return &user, err
}

// GenLoadUser loads the given User given the id
func GenLoadUser(viewer viewer.ViewerContext, id string, chanUserResult chan<- UserResult) {
	var user User
	chanErr := make(chan error)
	go ent.GenLoadNode(viewer, id, &user, &configs.UserConfig{}, chanErr)
	err := <-chanErr
	chanUserResult <- UserResult{
		User:  &user,
		Error: err,
	}
}

// GenEventsEdges returns the Event edges associated with the User instance
func (user *User) GenEventsEdges(chanEdgesResult chan<- ent.EdgesResult) {
	go ent.GenLoadEdgesByTypeResult(user.ID, UserToEventsEdge, chanEdgesResult)
}

func (user *User) LoadEventsByType(id2 string) (*ent.Edge, error) {
	return ent.LoadEdgeByType(user.ID, UserToEventsEdge, id2)
}

// GenEvents returns the Events associated with the User instance
func (user *User) GenEvents(chanEventsResult chan<- EventsResult) {
	var events []*Event
	chanErr := make(chan error)
	go ent.GenLoadNodesByType(user.Viewer, user.ID, UserToEventsEdge, &events, &configs.EventConfig{}, chanErr)
	err := <-chanErr
	chanEventsResult <- EventsResult{
		Events: events,
		Error:  err,
	}
}

// LoadEvents returns the Events associated with the User instance
func (user *User) LoadEvents() ([]*Event, error) {
	var events []*Event
	err := ent.LoadNodesByType(user.Viewer, user.ID, UserToEventsEdge, &events, &configs.EventConfig{})
	return events, err
}

func (user *User) FillFromMap(data map[string]interface{}) error {
	for k, v := range data {
		var err error
		switch k {
		case "id":
			user.ID, err = cast.ToUUIDString(v)
			if err != nil {
				return err
			}
			break
		case "email_address":
			user.EmailAddress, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		case "first_name":
			user.FirstName, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		case "last_name":
			user.LastName, err = cast.ToString(v)
			if err != nil {
				return err
			}
			break
		}
	}
	return nil
}

var _ ent.Entity = &User{}
