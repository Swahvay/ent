package main

import (
	"bytes"
	"fmt"
	"text/template"

	intimports "github.com/lolopinto/ent/internal/imports"
	"github.com/lolopinto/ent/internal/util"
	"golang.org/x/tools/imports"
)

type templatedBasedFileWriter struct {
	data               interface{}
	pathToTemplate     string
	templateName       string
	pathToFile         string
	createDirIfNeeded  bool
	checkForManualCode bool
	formatSource       bool
	funcMap            template.FuncMap
	packageName        string
	//	manualImports      bool
	imports *intimports.Imports
}

func (fw *templatedBasedFileWriter) CreateDirIfNeeded() bool {
	return fw.createDirIfNeeded
}

func (fw *templatedBasedFileWriter) GetPathToFile() string {
	return fw.pathToFile
}

func (fw *templatedBasedFileWriter) GenerateBytes() []byte {
	// parse existing file to see what we need to keep in the rewrite
	var config *astConfig

	// no real reason this only applies for just privacy.tmpl
	// but it's the only one where we care about this for now so limiting to just that
	// in the future, this should apply for all
	if fw.checkForManualCode {
		config = parseFileForManualCode(fw.pathToFile)
	}

	// generate the new AST we want for the file
	buf := fw.generateNewAst()

	// better flag needed. but basically not go code and we can bounce
	if !fw.formatSource {
		return buf.Bytes()
	}

	var b []byte
	var err error
	if fw.imports != nil {
		buf = fw.handleManualImports(buf)
	}

	b, err = imports.Process(
		fw.pathToFile,
		buf.Bytes(),
		&imports.Options{
			FormatOnly: false,
			Comments:   true,
			TabIndent:  true,
			TabWidth:   8,
		},
	)
	if err != nil {
		fmt.Println(string(buf.Bytes()))
		util.Die(err)
	}

	// if fw.formatSource {
	// 	b, err = format.Source(buf.Bytes())

	// 	if err != nil {
	// 		fmt.Println(buf.String())
	// 	}
	// 	util.Die(err)
	// }

	if config != nil {
		b = rewriteAstWithConfig(config, b)
	}
	return b
}

// TODO rename this since this is just parse template that's non-AST
// generate new AST for the given file from the template
func (fw *templatedBasedFileWriter) generateNewAst() *bytes.Buffer {
	templateAbsPath := getAbsolutePath(fw.pathToTemplate)

	path := []string{templateAbsPath}
	t := template.New(fw.templateName).Funcs(fw.funcMap)
	t, err := t.ParseFiles(path...)
	util.Die(err)

	var buffer bytes.Buffer

	// execute the template and store in buffer
	err = t.Execute(&buffer, fw.data)
	util.Die(err)
	//err = t.Execute(os.Stdout, nodeData)
	//fmt.Println(buffer)
	//	fmt.Println(buffer.String())

	return &buffer
}

func (fw *templatedBasedFileWriter) handleManualImports(buf *bytes.Buffer) *bytes.Buffer {
	var result bytes.Buffer
	result.WriteString("// Code generated by github.com/lolopinto/ent/ent, DO NOT EDIT.\n\n")

	result.WriteString("package ")
	result.WriteString(fw.packageName)
	result.WriteString("\n\n")
	result.WriteString("import (\n")
	result.WriteString(fw.imports.String())
	result.WriteString(")\n")
	_, err := buf.WriteTo(&result)

	util.Die((err))

	return &result
}
