// Code generated by github.com/lolopinto/ent/ent, DO NOT edit. 

package models

{{with .CodePath -}}
import (
  "context"

  "github.com/lolopinto/ent/ent"
  "github.com/lolopinto/ent/ent/privacy"
  "github.com/lolopinto/ent/ent/viewer"

  {{.PathToConfigs}}
)
{{end -}}

{{with .NodeData -}}
{{with .ConstantGroups -}}
const (
  {{ range . -}}
    {{$constType := .ConstType -}}
    {{range .Constants -}}
      // {{.Comment}}
      {{.ConstName}} {{$constType}} = {{.ConstValue}}
    {{end}}

  {{end -}}
)
{{end -}}

// {{.Node}} represents the `{{.Node}}` model 
type {{.Node}} struct {
  ent.Node
  {{ range $field := .FieldInfo.Fields -}} 
    {{if topLevelStructField $field -}}
      {{$field.FieldName}} {{fTypeString $field}} {{$field.FieldTag}}
    {{end -}}
  {{end -}}
  Viewer viewer.ViewerContext
}


// {{.NodeResult}} stores the result of loading a {{.Node}}. It's a tuple type which has 2 fields: 
// a {{.Node}} and an error
type {{.NodeResult}} struct {
  {{.Node}} *{{.Node}}
  Error error
}

// {{.NodesResult}} stores the result of loading a slice of {{.Node}}s. It's a tuple type which has 2 fields: 
// a {{.NodesSlice}} and an error
type {{.NodesResult}} struct {
  {{.Nodes}} {{.NodesSlice}}
  Error error
}

// IsNode is needed by gqlgen to indicate that this implements the Node interface in GraphQL
func ({{.NodeInstance}} {{.Node}}) isNode() {}

// GetType returns the NodeType of this entity. In this case: ContactType
func ({{.NodeInstance}} *{{.Node}}) GetType() ent.NodeType {
	return {{.NodeType}}
}

// GetPrivacyPolicy returns the PrivacyPolicy of this entity. 
func ({{.NodeInstance}} *{{.Node}}) GetPrivacyPolicy() privacy.Policy {
  return {{.Node}}PrivacyPolicy{
    {{.Node}}: {{.NodeInstance}},
  }
}

// Load{{.Node}}FromContext loads the given {{.Node}} given the context and id
func Load{{.Node}}FromContext(ctx context.Context, id string) (*{{.Node}}, error) {
  v, err := viewer.ForContext(ctx)
  if err != nil {
    return nil, err
  }
	return Load{{.Node}}(v, id)
}

// Load{{.Node}} loads the given {{.Node}} given the viewer and id
func Load{{.Node}}(viewer viewer.ViewerContext, id string) (*{{.Node}}, error) {
  var {{.NodeInstance}} {{.Node}}
  err := ent.LoadNode(viewer, id, &{{.NodeInstance}}, {{.EntConfig}})
  return &{{.NodeInstance}}, err
}

// GenLoad{{.Node}} loads the given {{.Node}} given the id
func GenLoad{{.Node}}(viewer viewer.ViewerContext, id string, chan{{.NodeResult}} chan<- {{.NodeResult}}) {
  var {{.NodeInstance}} {{.Node}}
  chanErr := make(chan error)
  go ent.GenLoadNode(viewer, id, &{{.NodeInstance}}, {{.EntConfig}}, chanErr)
  err := <-chanErr
  chan{{.NodeResult}} <- {{.NodeResult}}{
    {{.Node}}: &{{.NodeInstance}},
    Error: err,
  }
}

{{/* todo: deal with importing right packages above and circular dependency all that jazz*/}}
{{/* this should be user/factory. user/config? user/query user/privacy etc. */}}
{{with . -}}
  {{$currentNodeInstance := .NodeInstance}}
  {{$currentNode := .Node}}
  {{$currentPackageName := .PackageName}}
  {{with .EdgeInfo}}
    {{range $edge := .FieldEdges -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(chan{{.NodeResult}} chan<- {{.NodeResult}}) {
          go GenLoad{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}}, chan{{.NodeResult}} )
        }

        // Load{{$edgeName}} returns the {{$edgeName}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() (*{{.Node}}, error) {
          return Load{{.Node}}({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.{{$edge.FieldName}})
        }
      {{end}}
    {{end}}
    {{range $edge := .ForeignKeys -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(chan{{.NodesResult}} chan<- {{.NodesResult}}) {
          var {{.NodeInstance}}s {{.NodesSlice}}
          chanErr := make(chan error)
          go ent.GenLoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, &{{.NodeInstance}}s, "{{$currentPackageName}}_id", {{.EntConfig}}, chanErr)
          err := <-chanErr
          chan{{.NodesResult}} <- {{.NodesResult}}{
            {{.Nodes}}: {{.NodeInstance}}s,
            Error: err,
          }
        }

        // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
          var {{.NodeInstance}}s {{.NodesSlice}}
          err := ent.LoadForeignKeyNodes({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, &{{.NodeInstance}}s, "{{$currentPackageName}}_id", {{.EntConfig}})
          return {{.NodeInstance}}s, err
        }
      {{end}}
    {{end}}
    {{range $edge := .Associations -}}
      {{$edgeName := .EdgeName -}}
      {{with .NodeInfo -}}
        // Gen{{$edgeName}}Edges returns the {{.Node}} edges associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}Edges(chanEdgesResult chan<- ent.EdgesResult) {
          go ent.GenLoadEdgesByTypeResult({{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, chanEdgesResult)
        }

        // Gen{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Gen{{$edgeName}}(chan{{.NodesResult}} chan<- {{.NodesResult}}) {
          var {{.NodeInstance}}s {{.NodesSlice}}
          chanErr := make(chan error)
          go ent.GenLoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}s, chanErr)
          err := <-chanErr
          chan{{.NodesResult}} <- {{.NodesResult}}{
            {{.Nodes}}: {{.NodeInstance}}s,
            Error: err,
          }
        }

        // Load{{$edgeName}} returns the {{.Nodes}} associated with the {{$currentNode}} instance
        func ({{$currentNodeInstance}} *{{$currentNode}}) Load{{$edgeName}}() ({{.NodesSlice}}, error) {
          var {{.NodeInstance}}s {{.NodesSlice}}
          err := ent.LoadNodesByType({{$currentNodeInstance}}.Viewer, {{$currentNodeInstance}}.ID, {{$edge.EdgeConst}}, &{{.NodeInstance}}s)
          return {{.NodeInstance}}s, err
        }
      {{end}}
    {{end}}
  {{end}}
{{end}}

// Add this to each entity to confirm it implements the interface
var _ ent.Entity = (*{{.Node}})(nil)


{{end -}}
