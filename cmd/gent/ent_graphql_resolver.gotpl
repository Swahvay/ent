{{ reserveImport "context"  }}
{{ reserveImport "fmt"  }}
{{ reserveImport "io"  }}
{{ reserveImport "strconv"  }}
{{ reserveImport "time"  }}
{{ reserveImport "sync"  }}
{{ reserveImport "errors"  }}
{{ reserveImport "bytes"  }}

{{ reserveImport "github.com/99designs/gqlgen/handler" }}
{{ reserveImport "github.com/vektah/gqlparser" }}
{{ reserveImport "github.com/vektah/gqlparser/ast" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql" }}
{{ reserveImport "github.com/99designs/gqlgen/graphql/introspection" }}

type {{.ResolverType}} struct {}

{{ range $object := .Objects -}}
	{{- if $object.HasResolvers -}}
		func (r *{{$.ResolverType}}) {{$object.Name}}() {{ $object.ResolverInterface | ref }} {
			return &{{lcFirst $object.Name}}{{ucFirst $.ResolverType}}{r}
		}
	{{ end -}}
{{ end }}

{{ range $object := .Objects -}}
	{{- if $object.HasResolvers -}}
		type {{lcFirst $object.Name}}{{ucFirst $.ResolverType}} struct { *{{$.ResolverType}} }

		{{ range $field := $object.Fields -}}
			{{- if $field.IsResolver }}
			func (r *{{lcFirst $object.Name}}{{ucFirst $.ResolverType}}) {{$field.GoFieldName}}{{ $field.ShortResolverDeclaration }} {

{{- /*todo this is the basics that's cheating. we need to define functions that take field and object information and figure out what type of field it is and do something about it*/ -}}
        {{- if castToString $field -}}
          return string(obj.OwnerType), nil
        {{- else if loadObjectFromContext $field -}}
          return models.Load{{$field.GoFieldName}}FromContext(ctx, id)
				{{- else if fieldEdge $field -}}
					return obj.Load{{$field.GoFieldName}}()
				{{- else -}}
					panic("not implemented")
        {{ end -}}
			}
			{{ end -}}
		{{ end -}}
	{{ end -}}
{{ end }}
